
import math
import socket
import tempfile
import unittest
from contextlib import closing

import numpy as np

from shyft.api import (
    Calendar, UtcPeriod,
    DtsServer, DtsClient,
    TimeAxis, TimeSeries, POINT_AVERAGE_VALUE, POINT_INSTANT_VALUE
)
from shyft.pyapi import fixed_tsv, windowed_percentiles_tsv, period_percentiles_tsv, selector_ts


def find_free_port() -> int:
    """
    from SO https://stackoverflow.com/questions/1365265/on-localhost-how-to-pick-a-free-port-number
    :return: available port number for use
    """
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
        s.bind(('', 0))
        return s.getsockname()[1]


class SelectorTsTestCase(unittest.TestCase):

    def setUp(self) -> None:
        self.port = find_free_port()

        self.server = DtsServer()
        self.server.set_listening_port(self.port)

        self.server.start_async()

        self.client = DtsClient(rf'localhost:{self.port}')

    def tearDown(self) -> None:
        self.server.clear()

        del self.server
        del self.port

    def test_fixed_tsv_empty(self) -> None:
        """Test that an empty TsVector is generated by fixed_tsv when given an empty sequence of values."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        tsv = fixed_tsv(period, [])
        self.assertEqual(len(tsv), 0)

    def test_fixed_tsv_values(self) -> None:
        """Test that a TsVector with fixed constant values is generated by fixed_tsv when given
        a sequence of values."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        values = [12, 15.5]
        tsv = fixed_tsv(period, values)
        self.assertEqual(len(tsv), 2)
        for v, ts in zip(values, tsv):
            for ts_v in ts.values:
                self.assertEqual(ts_v, v)

    def test_windowed_percentiles_tsv_empty(self) -> None:
        """Test that an empty TsVector is generated by windowed_percentiles_tsv
        when given an empty sequence of percentiles."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        data = np.linspace(-2, 2, 24*7)
        data_ts = TimeSeries(TimeAxis(0, Calendar.HOUR, len(data)), data, POINT_INSTANT_VALUE)

        # compute
        tsv = windowed_percentiles_tsv(
            data_ts, period,
            Calendar.HOUR, Calendar.HOUR,
            [],
            self.client, cal
        )
        self.assertEqual(len(tsv), 0)

    def test_windowed_percentiles_tsv_values(self) -> None:
        """Test that a TsVector is generated by windowed_percentiles_tsv with time-series
        fulfilling some properties of being percentiles of the data ts."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        data = np.linspace(-2, 2, 24*7)
        data_ts = TimeSeries(TimeAxis(0, Calendar.HOUR, len(data)), data, POINT_INSTANT_VALUE)

        # compute
        percentiles = [0, 10, 50, 90, 100]
        tsv = windowed_percentiles_tsv(
            data_ts, period,
            3*Calendar.HOUR, 12*Calendar.HOUR,
            percentiles,
            self.client, cal
        )
        self.assertEqual(len(tsv), 5)

        # assert that the time-series have the correct properties for being percentile series
        for i in range(len(tsv[0])):
            prev_v = tsv[0].values[i]
            for j in range(len(percentiles)-1):
                v = tsv[j+1].values[i]
                # both values will be NaN at the end - that is ok
                if math.isnan(prev_v) and math.isnan(v):
                    continue
                # check that no larger percentile have values greater than lower percentiles
                self.assertLessEqual(prev_v, v)
                prev_v = v

    def test_period_percentiles_tsv_empty(self) -> None:
        """Test that an empty TsVector is generated by period_percentiles_tsv
        when given an empty sequence of percentiles."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        data = np.linspace(-2, 2, 24*7)
        data_ts = TimeSeries(TimeAxis(0, Calendar.HOUR, len(data)), data, POINT_INSTANT_VALUE)

        # compute
        tsv = period_percentiles_tsv(
            data_ts, period,
            3*Calendar.HOUR, period,
            [],
            self.client, cal
        )
        self.assertEqual(len(tsv), 0)

    def test_period_percentiles_tsv_values(self) -> None:
        """Test that a TsVector is generated by period_percentiles_tsv with time-series
        fulfilling some properties of being percentiles of the data ts."""
        cal = Calendar()
        period = UtcPeriod(cal.time(2017, 1, 1), cal.time(2018, 1, 1))

        data = np.linspace(-2, 2, 24*7)
        data_ts = TimeSeries(TimeAxis(0, Calendar.HOUR, len(data)), data, POINT_INSTANT_VALUE)

        # compute
        percentiles = [0, 10, 50, 90, 100]
        tsv = period_percentiles_tsv(
            data_ts, period,
            3*Calendar.HOUR, period,
            percentiles,
            self.client, cal
        )
        self.assertEqual(len(tsv), 5)

        # assert that the time-series have the correct properties for being percentile series
        for i in range(len(tsv[0])):
            prev_v = tsv[0].values[i]
            for j in range(len(percentiles)-1):
                v = tsv[j+1].values[i]
                # both values will be NaN at the end - that is ok
                if math.isnan(prev_v) and math.isnan(v):
                    continue
                # check that no larger percentile have values greater than lower percentiles
                self.assertLessEqual(prev_v, v)
                prev_v = v

    def test_selector_ts(self) -> None:
        """Test that selector_ts constructs a time-series selects data from different time-series correctly."""
        n = 24
        cal = Calendar()
        period = UtcPeriod(0, n*Calendar.HOUR)

        data_ts = TimeSeries(TimeAxis(0, Calendar.HOUR, n), np.linspace(-10, 10, n), POINT_INSTANT_VALUE)
        source_tss = [
            TimeSeries(TimeAxis(0, Calendar.HOUR, n), 1.00*np.ones(n), POINT_INSTANT_VALUE),
            TimeSeries(TimeAxis(0, Calendar.HOUR, n), 10.0*np.ones(n), POINT_INSTANT_VALUE),
            TimeSeries(TimeAxis(0, Calendar.HOUR, n), 100.*np.ones(n), POINT_INSTANT_VALUE),
        ]
        threshold_1 = -5
        threshold_2 = 5
        threshold_tss = [
            TimeSeries(TimeAxis(0, Calendar.HOUR, n), threshold_1*np.ones(n), POINT_INSTANT_VALUE),
            TimeSeries(TimeAxis(0, Calendar.HOUR, n), threshold_2*np.ones(n), POINT_INSTANT_VALUE),
        ]

        ts = selector_ts(
            data_ts, period, 2*Calendar.HOUR,
            threshold_tss, source_tss,
            POINT_AVERAGE_VALUE,
            self.client, cal
        )

        self.assertEqual(len(data_ts), len(ts))
        for dv, rv in zip(data_ts.values, ts.values):
            if dv < threshold_1:
                self.assertEqual(rv, source_tss[0].values[0])
            elif threshold_1 <= dv < threshold_2:
                self.assertEqual(rv, source_tss[1].values[0])
            else:
                self.assertEqual(rv, source_tss[2].values[0])
